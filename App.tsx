import React, { useState, useCallback, useEffect } from 'react';
import * as geminiService from './services/geminiService';
import * as openaiService from './services/openaiService';
import * as anthropicService from './services/anthropicService';
import * as nodeBuilderService from './services/nodeBuilderService';
import type { GeneratedFile, TerminalMessage, UploadedFile, CreationMode, Project, VideoGenRequest, AIProvider, OpenAIModel, AnthropicModel, GeminiModel, ApiKeyConfig, AIProviderModel, GeneratedAppPayload, MistralModel, XAIModel, CohereModel, MetaModel, GenerationContext, GenerationResult, AppView } from './types';
import { LandingPage } from './components/LandingPage';
import { IterationView } from './components/IterationView';
import { PlanningView } from './components/PlanningView';
import { NodeBuilderView } from './components/NodeBuilderView';
import { LoadingSpinner } from './components/common/LoadingSpinner';
import { ErrorMessage } from './components/common/ErrorMessage';
import { ApiKeyModal } from './components/common/ApiKeyModal';
import { v4 as uuidv4 } from 'uuid';
import { getDefaultModelForProvider, getModelById, creationModeToLabel } from './types';
import { BinaryRain } from './components/common/BinaryRain';

type Theme = 'pixel' | 'terminal' | 'binary';

const LOCAL_STORAGE_PROJECTS_KEY = 'vortexAppProjects_v2';
const LOCAL_STORAGE_THEME_KEY = 'vortexAppTheme';
const MEDIA_GENERATION_LIMIT_KEY = 'vortexMediaGenLimit_v1';
const DAILY_MEDIA_LIMIT = 5;
const AI_PROVIDER_CONFIG_KEY_PREFIX = 'vortexAiProviderConfig_v2_'; // Updated prefix for new model structure
const PREFERRED_AI_PROVIDER_KEY = 'vortexPreferredAiProvider_v2';


const defaultFiles: GeneratedFile[] = [
    { path: 'public/index.html', content: '<!DOCTYPE html><html><head><title>New App</title><link rel="stylesheet" href="./style.css"></head><body><h1>Hello, Vortex!</h1><script src="./script.js"></script></body></html>' },
    { path: 'public/style.css', content: 'body { font-family: sans-serif; margin: 20px; background-color: #f0f0f0; } h1 { color: #333; }' },
    { path: 'public/script.js', content: 'console.log("App loaded!");' }
];
const defaultEntryPoint = 'public/index.html';

const ThemeToggleButton: React.FC<{ theme: Theme; onToggle: () => void }> = ({ theme, onToggle }) => {
    const icon = theme === 'pixel' ? 'terminal' : theme === 'terminal' ? 'data_object' : 'palette';
    const label = theme === 'pixel' ? 'Switch to Terminal Mode' : theme === 'terminal' ? 'Switch to Binary Mode' : 'Switch to Pixel Mode';

    return (
        <button
            onClick={onToggle}
            title={label}
            aria-label={label}
            className="fixed bottom-4 right-4 z-50 flex items-center justify-center w-14 h-14 rounded-full bg-primary text-on-primary shadow-lg hover:bg-opacity-90 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2 focus:ring-offset-bg-main transition-all duration-200 ease-in-out transform hover:scale-110"
        >
            <span className="material-symbols-outlined text-2xl">{icon}</span>
        </button>
    );
};

const App: React.FC = () => {
  const [currentView, setCurrentView] = useState<AppView>('landing');
  const [theme, setTheme] = useState<Theme>('terminal');
  
  const [isPlanModeEnabled, setIsPlanModeEnabled] = useState<boolean>(false);
  const [generatedPlan, setGeneratedPlan] = useState<string | null>(null);
  const [generationContext, setGenerationContext] = useState<GenerationContext | null>(null);

  const [initialPrompt, setInitialPrompt] = useState<string>('');
  const [appName, setAppName] = useState<string>('Untitled Vortex App');
  const [appDescription, setAppDescription] = useState<string>('A new app generated by Vortex.');

  const [editedFiles, setEditedFiles] = useState<GeneratedFile[]>([]);
  const [currentEntryPoint, setCurrentEntryPoint] = useState<string>(defaultEntryPoint);

  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [loadingMessage, setLoadingMessage] = useState<string>('Generating your app...');
  const [loadingContextPrompt, setLoadingContextPrompt] = useState<string | undefined>(undefined);
  const [error, setError] = useState<string | null>(null);
  const [apiKeyStatus, setApiKeyStatus] = useState<string>('');

  const [previewKey, setPreviewKey] = useState<number>(0);
  const [terminalMessages, setTerminalMessages] = useState<TerminalMessage[]>([]);
  const [uploadedFile, setUploadedFile] = useState<UploadedFile | null>(null);
  const [browserInspirationUrl, setBrowserInspirationUrl] = useState<string | null>(null);
  const [figmaInspiration, setFigmaInspiration] = useState<string | null>(null);
  const [creationMode, setCreationMode] = useState<CreationMode>('app');

  const [savedProjects, setSavedProjects] = useState<Project[]>([]);
  const [currentProjectId, setCurrentProjectId] = useState<string | null>(null);
  const [selectedProjectIdsForMixing, setSelectedProjectIdsForMixing] = useState<string[]>([]);

  // AI Provider State
  const [aiProvider, setAiProvider] = useState<AIProvider>('gemini');
  const [openaiApiKey, setOpenaiApiKey] = useState<string | null>(null);
  const [anthropicApiKey, setAnthropicApiKey] = useState<string | null>(null);
  const [mistralApiKey, setMistralApiKey] = useState<string | null>(null);
  const [xaiApiKey, setXaiApiKey] = useState<string | null>(null);
  const [cohereApiKey, setCohereApiKey] = useState<string | null>(null);
  const [metaApiKey, setMetaApiKey] = useState<string | null>(null);

  const [geminiModel, setGeminiModel] = useState<GeminiModel>(getDefaultModelForProvider('gemini') as GeminiModel);
  const [openaiModel, setOpenaiModel] = useState<OpenAIModel>(getDefaultModelForProvider('openai') as OpenAIModel);
  const [anthropicModel, setAnthropicModel] = useState<AnthropicModel>(getDefaultModelForProvider('anthropic') as AnthropicModel);
  const [mistralModel, setMistralModel] = useState<MistralModel>(getDefaultModelForProvider('mistral') as MistralModel);
  const [xaiModel, setXaiModel] = useState<XAIModel>(getDefaultModelForProvider('xai') as XAIModel);
  const [cohereModel, setCohereModel] = useState<CohereModel>(getDefaultModelForProvider('cohere') as CohereModel);
  const [metaModel, setMetaModel] = useState<MetaModel>(getDefaultModelForProvider('meta') as MetaModel);

  const [showApiKeyModal, setShowApiKeyModal] = useState<AIProvider | null>(null);
  const [apiKeyModalTargetModel, setApiKeyModalTargetModel] = useState<AIProviderModel | undefined>(undefined);

  // Theme management
  useEffect(() => {
    const savedTheme = localStorage.getItem(LOCAL_STORAGE_THEME_KEY) as Theme;
    if (savedTheme && ['pixel', 'terminal', 'binary'].includes(savedTheme)) {
        setTheme(savedTheme);
    }
  }, []);

  useEffect(() => {
    document.body.className = ''; // Clear existing classes
    document.body.classList.add(`theme-${theme}`, 'antialiased');
    localStorage.setItem(LOCAL_STORAGE_THEME_KEY, theme);
  }, [theme]);

  const handleThemeToggle = () => {
    setTheme(prevTheme => {
        if (prevTheme === 'pixel') return 'terminal';
        if (prevTheme === 'terminal') return 'binary';
        return 'pixel';
    });
  };

  const addSystemMessageToTerminal = useCallback((message: string, level: TerminalMessage['level'] = 'system') => {
    setTerminalMessages(prev => [...prev, {
      id: uuidv4(),
      level,
      payload: [message],
      timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' })
    }]);
  }, []);

  // Load AI provider configs from localStorage
  useEffect(() => {
    const geminiKeyPresent = !!process.env.API_KEY;
    if (!geminiKeyPresent) {
        setApiKeyStatus('Gemini API Key (process.env.API_KEY) not detected. Gemini features may be limited.');
        addSystemMessageToTerminal('Warning: Gemini API Key (process.env.API_KEY) not found in environment.', 'warn');
    } else {
        setApiKeyStatus('');
    }

    const loadProviderConfig = (provider: AIProvider) => {
        const storedConfig = localStorage.getItem(`${AI_PROVIDER_CONFIG_KEY_PREFIX}${provider}`);
        if (storedConfig) {
            try {
                const config = JSON.parse(storedConfig);
                if (provider === 'gemini' && config.model) {
                    setGeminiModel(config.model as GeminiModel);
                } else if (provider === 'openai' && config.apiKey && config.model) {
                    setOpenaiApiKey(config.apiKey);
                    setOpenaiModel(config.model as OpenAIModel);
                } else if (provider === 'anthropic' && config.apiKey && config.model) {
                    setAnthropicApiKey(config.apiKey);
                    setAnthropicModel(config.model as AnthropicModel);
                } else if (provider === 'mistral' && config.apiKey && config.model) {
                    setMistralApiKey(config.apiKey);
                    setMistralModel(config.model as MistralModel);
                } else if (provider === 'xai' && config.apiKey && config.model) {
                    setXaiApiKey(config.apiKey);
                    setXaiModel(config.model as XAIModel);
                } else if (provider === 'cohere' && config.apiKey && config.model) {
                    setCohereApiKey(config.apiKey);
                    setCohereModel(config.model as CohereModel);
                } else if (provider === 'meta' && config.apiKey && config.model) {
                    setMetaApiKey(config.apiKey);
                    setMetaModel(config.model as MetaModel);
                }
            } catch (e) {
                console.error(`Error parsing localStorage for ${provider}:`, e);
                localStorage.removeItem(`${AI_PROVIDER_CONFIG_KEY_PREFIX}${provider}`);
            }
        }
    };

    loadProviderConfig('gemini');
    loadProviderConfig('openai');
    loadProviderConfig('anthropic');
    loadProviderConfig('mistral');
    loadProviderConfig('xai');
    loadProviderConfig('cohere');
    loadProviderConfig('meta');

    const preferredProvider = localStorage.getItem(PREFERRED_AI_PROVIDER_KEY) as AIProvider | null;
    if (preferredProvider) {
        setAiProvider(preferredProvider);
    }
  }, [addSystemMessageToTerminal]);


  const handleSaveApiKeyConfig = (config: ApiKeyConfig) => {
    const newConfigToStore = { apiKey: config.apiKey, model: config.model };
    localStorage.setItem(`${AI_PROVIDER_CONFIG_KEY_PREFIX}${config.provider}`, JSON.stringify(newConfigToStore));

    let modelDisplayName = getModelById(config.model)?.name || config.model;

    if (config.provider === 'openai') {
      setOpenaiApiKey(config.apiKey);
      setOpenaiModel(config.model as OpenAIModel);
      addSystemMessageToTerminal(`OpenAI API Key configured. Model set to: ${modelDisplayName}.`, 'info');
    } else if (config.provider === 'anthropic') {
      setAnthropicApiKey(config.apiKey);
      setAnthropicModel(config.model as AnthropicModel);
      addSystemMessageToTerminal(`Anthropic API Key configured. Model set to: ${modelDisplayName}.`, 'info');
    } else if (config.provider === 'mistral') {
      setMistralApiKey(config.apiKey);
      setMistralModel(config.model as MistralModel);
      addSystemMessageToTerminal(`Mistral API Key configured. Model set to: ${modelDisplayName}.`, 'info');
    } else if (config.provider === 'xai') {
      setXaiApiKey(config.apiKey);
      setXaiModel(config.model as XAIModel);
      addSystemMessageToTerminal(`xAI API Key configured. Model set to: ${modelDisplayName}.`, 'info');
    } else if (config.provider === 'cohere') {
      setCohereApiKey(config.apiKey);
      setCohereModel(config.model as CohereModel);
      addSystemMessageToTerminal(`Cohere API Key configured. Model set to: ${modelDisplayName}.`, 'info');
    } else if (config.provider === 'meta') {
      setMetaApiKey(config.apiKey);
      setMetaModel(config.model as MetaModel);
      addSystemMessageToTerminal(`Meta API Key configured. Model set to: ${modelDisplayName}.`, 'info');
    }
    // No API key to save for Gemini here, model preference is handled by handleSelectModel
    setShowApiKeyModal(null);
    setApiKeyModalTargetModel(undefined);
  };

  const handleSelectModel = (provider: AIProvider, modelId: AIProviderModel) => {
    setAiProvider(provider);
    localStorage.setItem(PREFERRED_AI_PROVIDER_KEY, provider);

    const currentProviderConfigStr = localStorage.getItem(`${AI_PROVIDER_CONFIG_KEY_PREFIX}${provider}`);
    let currentProviderConfig = currentProviderConfigStr ? JSON.parse(currentProviderConfigStr) : {};

    currentProviderConfig.model = modelId;

    if (provider === 'gemini') {
        setGeminiModel(modelId as GeminiModel);
    } else if (provider === 'openai') {
        setOpenaiModel(modelId as OpenAIModel);
        if (!openaiApiKey) {
            setShowApiKeyModal('openai');
            setApiKeyModalTargetModel(modelId);
        }
    } else if (provider === 'anthropic') {
        setAnthropicModel(modelId as AnthropicModel);
        if (!anthropicApiKey) {
            setShowApiKeyModal('anthropic');
            setApiKeyModalTargetModel(modelId);
        }
    } else if (provider === 'mistral') {
        setMistralModel(modelId as MistralModel);
        if (!mistralApiKey) {
            setShowApiKeyModal('mistral');
            setApiKeyModalTargetModel(modelId);
        }
    } else if (provider === 'xai') {
        setXaiModel(modelId as XAIModel);
        if (!xaiApiKey) {
            setShowApiKeyModal('xai');
            setApiKeyModalTargetModel(modelId);
        }
    } else if (provider === 'cohere') {
        setCohereModel(modelId as CohereModel);
        if (!cohereApiKey) {
            setShowApiKeyModal('cohere');
            setApiKeyModalTargetModel(modelId);
        }
    } else if (provider === 'meta') {
        setMetaModel(modelId as MetaModel);
        if (!metaApiKey) {
            setShowApiKeyModal('meta');
            setApiKeyModalTargetModel(modelId);
        }
    }

    // Save model preference even if API key is not set yet
    localStorage.setItem(`${AI_PROVIDER_CONFIG_KEY_PREFIX}${provider}`, JSON.stringify(currentProviderConfig));
    const modelDef = getModelById(modelId);
    addSystemMessageToTerminal(`Switched AI Provider to: ${provider.toUpperCase()}. Model: ${modelDef?.name || modelId}`, 'info');
  };

  const getCurrentActiveModelId = (): AIProviderModel => {
    switch(aiProvider) {
        case 'gemini': return geminiModel;
        case 'openai': return openaiModel;
        case 'anthropic': return anthropicModel;
        case 'mistral': return mistralModel;
        case 'xai': return xaiModel;
        case 'cohere': return cohereModel;
        case 'meta': return metaModel;
        default: return geminiModel; // Should not happen
    }
  };


  useEffect(() => {
    try {
      const storedProjects = localStorage.getItem(LOCAL_STORAGE_PROJECTS_KEY);
      if (storedProjects) {
        const parsedProjects: Project[] = JSON.parse(storedProjects);
        if (parsedProjects.every(p => Array.isArray(p.files) && typeof p.entryPoint === 'string' && p.aiProvider && p.aiModel)) {
          setSavedProjects(parsedProjects);
        } else {
          console.warn("Old project structure found or invalid projects in localStorage. Clearing.");
          localStorage.removeItem(LOCAL_STORAGE_PROJECTS_KEY);
        }
      }
    } catch (e) {
      console.error("Failed to load projects from localStorage:", e);
      addSystemMessageToTerminal("Error loading projects from local storage.", "error");
    }
  }, [addSystemMessageToTerminal]);

  useEffect(() => {
    try {
      localStorage.setItem(LOCAL_STORAGE_PROJECTS_KEY, JSON.stringify(savedProjects));
    } catch (e) {
      console.error("Failed to save projects to localStorage:", e);
      addSystemMessageToTerminal("Error saving projects to local storage. Changes might not persist.", "error");
    }
  }, [savedProjects, addSystemMessageToTerminal]);

  useEffect(() => {
    const handleIframeMessage = (event: MessageEvent) => {
      if (event.data && event.data.type === 'iframe_console_log') {
        const { level, payload } = event.data;
        setTerminalMessages(prevMessages => [...prevMessages, {
          id: uuidv4(), level, payload,
          timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' })
        }]);
      }
    };
    window.addEventListener('message', handleIframeMessage);
    return () => {
        window.removeEventListener('message', handleIframeMessage);
    }
  }, []);

  const handleClearTerminal = useCallback(() => setTerminalMessages([]), []);

  const saveCurrentProject = useCallback((
    currentData: {
      name: string;
      description: string;
      files: GeneratedFile[];
      entryPoint: string;
      mode: CreationMode;
      provider: AIProvider;
      modelUsed: AIProviderModel;
    },
    projectIdToUpdate: string | null
  ) => {
    const projectToSaveOmitId: Omit<Project, 'id' | 'lastSaved'> = {
      appName: currentData.name || "Untitled Project",
      appDescription: currentData.description || "No description.",
      files: currentData.files,
      entryPoint: currentData.entryPoint,
      creationMode: currentData.mode,
      aiProvider: currentData.provider,
      aiModel: currentData.modelUsed,
    };
    let finalProjectId = projectIdToUpdate;
    if (projectIdToUpdate) {
      setSavedProjects(prevProjects =>
        prevProjects.map(p =>
          p.id === projectIdToUpdate ? { ...projectToSaveOmitId, id: projectIdToUpdate, lastSaved: new Date().toISOString() } : p
        )
      );
      if (currentProjectId !== projectIdToUpdate) setCurrentProjectId(projectIdToUpdate);
      addSystemMessageToTerminal(`Project "${projectToSaveOmitId.appName}" updated. (Provider: ${currentData.provider}, Model: ${getModelById(currentData.modelUsed)?.name || currentData.modelUsed})`, 'info');
    } else {
      const newProject: Project = {
        id: uuidv4(),
        ...projectToSaveOmitId,
        lastSaved: new Date().toISOString(),
      };
      setSavedProjects(prevProjects => [newProject, ...prevProjects]);
      setCurrentProjectId(newProject.id);
      finalProjectId = newProject.id;
      addSystemMessageToTerminal(`Project "${newProject.appName}" saved. (Provider: ${currentData.provider}, Model: ${getModelById(currentData.modelUsed)?.name || currentData.modelUsed})`, 'info');
    }
    return finalProjectId;
  }, [addSystemMessageToTerminal, currentProjectId]);

  const handleLoadProject = useCallback((projectId: string) => {
    const projectToLoad = savedProjects.find(p => p.id === projectId);
    if (projectToLoad) {
      setAppName(projectToLoad.appName);
      setAppDescription(projectToLoad.appDescription);
      setEditedFiles(projectToLoad.files);
      setCurrentEntryPoint(projectToLoad.entryPoint);
      setCreationMode(projectToLoad.creationMode);
      setCurrentProjectId(projectToLoad.id);
      setInitialPrompt('');
      setUploadedFile(null);
      setBrowserInspirationUrl(null);
      setFigmaInspiration(null);
      setTerminalMessages([]);
      setSelectedProjectIdsForMixing([]);
      setGeneratedPlan(null);
      setGenerationContext(null);

      setAiProvider(projectToLoad.aiProvider);
      const modelId = projectToLoad.aiModel;
      if (projectToLoad.aiProvider === 'gemini') setGeminiModel(modelId as GeminiModel);
      else if (projectToLoad.aiProvider === 'openai') setOpenaiModel(modelId as OpenAIModel);
      else if (projectToLoad.aiProvider === 'anthropic') setAnthropicModel(modelId as AnthropicModel);
      else if (projectToLoad.aiProvider === 'mistral') setMistralModel(modelId as MistralModel);
      else if (projectToLoad.aiProvider === 'xai') setXaiModel(modelId as XAIModel);
      else if (projectToLoad.aiProvider === 'cohere') setCohereModel(modelId as CohereModel);
      else if (projectToLoad.aiProvider === 'meta') setMetaModel(modelId as MetaModel);


      addSystemMessageToTerminal(`Loaded project: "${projectToLoad.appName}". Provider: ${projectToLoad.aiProvider}, Model: ${getModelById(projectToLoad.aiModel)?.name || projectToLoad.aiModel}.`, 'info');
      setPreviewKey(prev => prev + 1);
      setCurrentView('iterating');
    } else {
      setError("Failed to load project. It might have been deleted.");
      addSystemMessageToTerminal(`Error: Could not find project with ID ${projectId}.`, 'error');
    }
  }, [savedProjects, addSystemMessageToTerminal]);

  const handleStartOver = useCallback((navigateToLanding = true) => {
    setEditedFiles([]);
    setCurrentEntryPoint(defaultEntryPoint);
    setInitialPrompt('');
    setAppName('Untitled Vortex App');
    setAppDescription('A new app generated by Vortex.');
    setError(null);
    setTerminalMessages([]);
    if(navigateToLanding) setCurrentView('landing');
    setUploadedFile(null);
    setBrowserInspirationUrl(null);
    setFigmaInspiration(null);
    setCreationMode('app');
    setCurrentProjectId(null);
    setSelectedProjectIdsForMixing([]);
    setGeneratedPlan(null);
    setGenerationContext(null);
    addSystemMessageToTerminal('Editor cleared. Ready for a new project or load an existing one.', 'system');
  }, [addSystemMessageToTerminal]);

  const handleDeleteProject = useCallback((projectId: string) => {
    setSavedProjects(prevProjects => prevProjects.filter(p => p.id !== projectId));
    setSelectedProjectIdsForMixing(prev => prev.filter(id => id !== projectId));
    addSystemMessageToTerminal(`Project with ID ${projectId} deleted.`, 'info');
    if (currentProjectId === projectId) {
      handleStartOver(false);
    }
  }, [currentProjectId, addSystemMessageToTerminal, handleStartOver]);

  const handleFileUpload = useCallback(async (file: File) => {
    if (file.type === 'application/zip' || file.name.endsWith('.zip') || file.type === 'application/x-zip-compressed') {
      setIsLoading(true);
      setLoadingMessage("Extracting ZIP file...");
      addSystemMessageToTerminal(`ZIP file "${file.name}" selected. Attempting extraction.`, 'info');
      setError(null);
      try {
        const JSZip = (window as any).JSZip;
        if (!JSZip) throw new Error("JSZip library is not available.");
        const zip = await JSZip.loadAsync(file);
        const extractedFiles: GeneratedFile[] = [];
        const filePromises: Promise<void>[] = [];
        zip.forEach((relativePath, zipEntry) => {
          if (!zipEntry.dir) {
            filePromises.push(
              zipEntry.async("string").then(content => {
                extractedFiles.push({ path: relativePath, content });
              })
            );
          }
        });
        await Promise.all(filePromises);
        if (extractedFiles.length === 0) throw new Error("ZIP file is empty or contains no processable files.");
        let entry = extractedFiles.find(f => f.path === 'public/index.html')?.path ||
                      extractedFiles.find(f => f.path === 'index.html')?.path ||
                      extractedFiles.find(f => f.path.endsWith('.html'))?.path;
        if (!entry && extractedFiles.length > 0) entry = extractedFiles[0].path;
        if (!entry) entry = defaultEntryPoint;
        const newProjectName = file.name.replace(/\.zip$/i, '') || "Imported Project";
        setAppName(newProjectName);
        setAppDescription(`Project extracted from ${file.name}. Contains ${extractedFiles.length} files. Entry: ${entry}`);
        setEditedFiles(extractedFiles);
        setCurrentEntryPoint(entry);
        setCurrentProjectId(null);
        setSelectedProjectIdsForMixing([]);
        setCreationMode('app');
        setUploadedFile(null);
        setGeneratedPlan(null);
        setGenerationContext(null);
        addSystemMessageToTerminal(`Successfully extracted ${extractedFiles.length} files from "${file.name}". Entry: ${entry}. This is a new unsaved project.`, 'info');
        setPreviewKey(prev => prev + 1);
        setCurrentView('iterating');
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "An unknown error occurred during ZIP extraction.";
        setError(`Failed to process ZIP file: ${errorMessage}`);
        addSystemMessageToTerminal(`Error processing ZIP "${file.name}": ${errorMessage}`, 'error');
        setUploadedFile(null);
      } finally {
        setIsLoading(false);
        setLoadingMessage('Generating your app...');
      }
    } else {
      addSystemMessageToTerminal(`File "${file.name}" (${file.type}) selected for media input.`, 'info');
      const reader = new FileReader();
      reader.onload = (e) => {
        const dataURL = e.target?.result as string;
        const base64DataWithPrefix = dataURL.split(',')[1];
        if (base64DataWithPrefix) {
          setUploadedFile({ name: file.name, mimeType: file.type, base64Data: base64DataWithPrefix, dataURL });
        } else {
          setError("Could not read file data.");
          addSystemMessageToTerminal(`Error reading file "${file.name}".`, 'error');
        }
      };
      reader.onerror = () => {
        setError("Error reading file.");
        addSystemMessageToTerminal(`Error reading file "${file.name}".`, 'error');
      };
      reader.readAsDataURL(file);
    }
  }, [addSystemMessageToTerminal]);

  const handleFileRemove = useCallback(() => {
    if (uploadedFile) {
      addSystemMessageToTerminal(`Media file "${uploadedFile.name}" removed.`, 'info');
      setUploadedFile(null);
    }
  }, [uploadedFile, addSystemMessageToTerminal]);

  const handleSetBrowserInspiration = useCallback((url: string | null) => {
    setBrowserInspirationUrl(url);
    if (url) addSystemMessageToTerminal(`Browser inspiration URL set: ${url}`, 'info');
    else addSystemMessageToTerminal('Browser inspiration URL cleared.', 'info');
  }, [addSystemMessageToTerminal]);

  const handleSetFigmaInspiration = useCallback((description: string | null) => {
    setFigmaInspiration(description);
    if (description) addSystemMessageToTerminal(`Figma inspiration set: "${description.substring(0, 50)}..."`, 'info');
    else addSystemMessageToTerminal('Figma inspiration cleared.', 'info');
  }, [addSystemMessageToTerminal]);

  const processGenerationResult = async (
      baseResult: GeneratedAppPayload,
      promptForLoading: string,
      currentAppNameForModification?: string,
      currentAppDescriptionForModification?: string,
      currentEntryPointForModification?: string
    ) => {
    let finalFiles = [...baseResult.files];
    let finalAppName = baseResult.appName || currentAppNameForModification || `My AI ${creationMode}`;
    let finalAppDescription = baseResult.appDescription || currentAppDescriptionForModification || `A ${creationMode} generated based on: "${promptForLoading.substring(0, 50)}..."`;
    let finalEntryPoint = baseResult.entryPoint || currentEntryPointForModification || defaultEntryPoint;

    let limitData;
    try {
      const storedLimit = localStorage.getItem(MEDIA_GENERATION_LIMIT_KEY);
      limitData = storedLimit ? JSON.parse(storedLimit) : { date: '', count: 0 };
    } catch (e) { limitData = { date: '', count: 0 }; }

    const today = new Date().toISOString().split('T')[0];
    if (limitData.date !== today) {
      limitData = { date: today, count: 0 };
    }

    // Image generation logic removed

    if (baseResult.videoGenerationRequests && baseResult.videoGenerationRequests.length > 0) {
        addSystemMessageToTerminal(`AI requested ${baseResult.videoGenerationRequests.length} video(s) to be generated.`, 'info');
        setLoadingMessage(prev => prev.replace("...", "") + " & generating videos...");

        const generatedVideoFiles: GeneratedFile[] = [];
        let videosSkippedDueToLimit = 0;

        for (const req of baseResult.videoGenerationRequests) {
            if (limitData.count >= DAILY_MEDIA_LIMIT) {
                setError("Daily media generation limit reached. Please try again tomorrow.");
                addSystemMessageToTerminal(`Video gen for "${req.prompt.substring(0,30)}..." skipped. Daily media limit reached.`, 'warn');
                videosSkippedDueToLimit++;
                continue;
            }
            try {
                addSystemMessageToTerminal(`Generating video (simulated): "${req.prompt.substring(0, 40)}..." -> ${req.targetFilePath}`, 'system');
                const placeholderVideoUrl = await geminiService.generateVideoFromPrompt(req.prompt); // Assuming Gemini is used for simulated video
                generatedVideoFiles.push({ path: req.targetFilePath, content: placeholderVideoUrl });
                limitData.count++;
                addSystemMessageToTerminal(`AI Video (simulated placeholder) available at path: ${req.targetFilePath}`, 'info');
            } catch (vidErr) {
                const errorMsg = vidErr instanceof Error ? vidErr.message : String(vidErr);
                addSystemMessageToTerminal(`Video gen (simulated) failed for "${req.prompt.substring(0,30)}...": ${errorMsg}`, 'error');
                if (!error) setError(errorMsg);
            }
        }
        if (generatedVideoFiles.length > 0) {
            const fileMap = new Map(finalFiles.map(f => [f.path, f]));
            generatedVideoFiles.forEach(vidFile => fileMap.set(vidFile.path, vidFile));
            finalFiles = Array.from(fileMap.values());
        }
        if (videosSkippedDueToLimit > 0 && generatedVideoFiles.length === 0 && baseResult.videoGenerationRequests.length === videosSkippedDueToLimit) {
            // Error already set by limit check
        } else if (videosSkippedDueToLimit > 0) {
            addSystemMessageToTerminal(`${videosSkippedDueToLimit} video(s) skipped due to daily media limit.`, 'warn');
        }
    }

    localStorage.setItem(MEDIA_GENERATION_LIMIT_KEY, JSON.stringify(limitData));
    return { name: finalAppName, description: finalAppDescription, files: finalFiles, entryPoint: finalEntryPoint };
  };

  const checkApiKeyAndPromptModal = (provider: AIProvider, modelId: AIProviderModel): boolean => {
    const providerUpperCase = provider.charAt(0).toUpperCase() + provider.slice(1);
    const commonMissingKeyError = (p: AIProvider) => {
        setShowApiKeyModal(p);
        setApiKeyModalTargetModel(modelId);
        const message = `${providerUpperCase} API Key is required. Please configure it.`;
        setError(message);
        addSystemMessageToTerminal(`${providerUpperCase} API Key missing. Please set it via the provider settings.`, "error");
        return false;
    }

    if (provider === 'openai' && !openaiApiKey) return commonMissingKeyError('openai');
    if (provider === 'anthropic' && !anthropicApiKey) return commonMissingKeyError('anthropic');
    if (provider === 'mistral' && !mistralApiKey) return commonMissingKeyError('mistral');
    if (provider === 'xai' && !xaiApiKey) return commonMissingKeyError('xai');
    if (provider === 'cohere' && !cohereApiKey) return commonMissingKeyError('cohere');
    if (provider === 'meta' && !metaApiKey) return commonMissingKeyError('meta');

    if (provider === 'gemini' && apiKeyStatus) {
        setError(apiKeyStatus + " Please ensure Gemini API_KEY is configured in your environment.");
        addSystemMessageToTerminal(apiKeyStatus, "error");
        return false;
    }
    return true;
  };

  const showProviderNotImplementedError = (provider: AIProvider, action: string = "Code generation") => {
    const providerName = provider.charAt(0).toUpperCase() + provider.slice(1);
    const message = `Provider ${providerName} integration is not yet fully implemented. ${action} is not available for this provider at the moment.`;
    setError(message);
    addSystemMessageToTerminal(message, 'warn');
    setIsLoading(false);
    setLoadingContextPrompt(undefined);
  };
  
  const executeCodeGeneration = useCallback(async (context: GenerationContext, plan?: string) => {
    const { prompt, creationMode, aiProvider, modelId, browserInspirationUrl, figmaInspiration, uploadedFile } = context;
    if (!checkApiKeyAndPromptModal(aiProvider, modelId)) { setIsLoading(false); return; }

    const modelDef = getModelById(modelId);
    setLoadingMessage(plan ? `Building from plan...` : `Crafting your ${creationModeToLabel(creationMode)}...`);
    setLoadingContextPrompt(prompt);
    setError(null);

    try {
      const mediaInputPayload = (uploadedFile && !uploadedFile.mimeType.includes('zip')) ? { mimeType: uploadedFile.mimeType, base64Data: uploadedFile.base64Data } : undefined;
      
      let generationResult: GenerationResult;
      
      switch(aiProvider) {
        case 'openai':
          if (!openaiApiKey) throw new Error("OpenAI API Key is missing.");
          generationResult = await openaiService.generateAppCode(prompt, creationMode, openaiApiKey, modelId as OpenAIModel, plan, browserInspirationUrl || undefined, figmaInspiration || undefined, mediaInputPayload);
          break;
        case 'anthropic':
          if (!anthropicApiKey) throw new Error("Anthropic API Key is missing.");
          generationResult = await anthropicService.generateAppCode(prompt, creationMode, anthropicApiKey, modelId as AnthropicModel, plan, browserInspirationUrl || undefined, figmaInspiration || undefined, mediaInputPayload);
          break;
        case 'gemini':
        default:
          generationResult = await geminiService.generateAppCode(prompt, creationMode, modelId as GeminiModel, plan, browserInspirationUrl || undefined, figmaInspiration || undefined, mediaInputPayload);
          break;
        case 'mistral':
        case 'xai':
        case 'cohere':
        case 'meta':
          showProviderNotImplementedError(aiProvider, `Initial ${creationModeToLabel(creationMode).toLowerCase()} generation`);
          return;
      }
      
      if (generationResult.sources && generationResult.sources.length > 0) {
        setTerminalMessages(prev => [...prev, {
            id: uuidv4(),
            level: 'system',
            payload: [`AI used web search to gather information for your request.`],
            sources: generationResult.sources,
            timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' })
        }]);
      }

      const processedResult = await processGenerationResult(generationResult.payload, prompt);
      
      const newProjectData = {
          ...processedResult,
          mode: creationMode,
          provider: aiProvider,
          modelUsed: modelId
      };
      
      setAppName(newProjectData.name);
      setAppDescription(newProjectData.description);
      setEditedFiles(newProjectData.files);
      setCurrentEntryPoint(newProjectData.entryPoint);
      
      const newProjectId = saveCurrentProject(newProjectData, null);
      setCurrentProjectId(newProjectId);
      
      setPreviewKey(prev => prev + 1);
      setCurrentView('iterating');
      setSelectedProjectIdsForMixing([]);
      addSystemMessageToTerminal(`"${newProjectData.name}" (via ${aiProvider.toUpperCase()}, Model: ${modelDef?.name || modelId}) generated and saved as new project!`, 'info');

    } catch (err) {
      console.error(`Error generating initial code with ${aiProvider} (${modelDef?.name || modelId}):`, err);
      const errorMessage = err instanceof Error ? err.message : "An unknown error occurred. Check console.";
      setError(errorMessage);
      addSystemMessageToTerminal(`Error generating initial code with ${aiProvider} (${modelDef?.name || modelId}): ${errorMessage}`, 'error');
      setCurrentView('landing');
    } finally {
      setIsLoading(false);
      setLoadingContextPrompt(undefined);
      setLoadingMessage('Generating your app...');
      setGenerationContext(null);
      setGeneratedPlan(null);
    }
  }, [addSystemMessageToTerminal, saveCurrentProject, openaiApiKey, anthropicApiKey]);


  const handleInitialGenerate = useCallback(async (description: string) => {
    const currentModelId = getCurrentActiveModelId();
    if (!checkApiKeyAndPromptModal(aiProvider, currentModelId)) { setIsLoading(false); return; }
    
    setTerminalMessages([]);
    let finalDescription = description;
    let scrapedUrl: string | undefined = undefined;
    if (description.toLowerCase().includes('/scrap')) {
        const parts = description.split('/scrap');
        const urlPart = parts[1]?.split(' ')[1];
        if (urlPart) {
            try {
                const validUrl = new URL(urlPart);
                scrapedUrl = validUrl.href;
                finalDescription = parts[0].trim() + (parts[1].substring(urlPart.length).trim());
                addSystemMessageToTerminal(`Scraping URL: ${scrapedUrl} for context.`, 'info');
            } catch (e) {
                addSystemMessageToTerminal(`Invalid URL for /scrap: ${urlPart}. Proceeding without scraping.`, 'warn');
            }
        } else {
             addSystemMessageToTerminal(`Malformed /scrap command. Usage: /scrap <url> <your idea>. Proceeding with full prompt.`, 'warn');
        }
    }

    const modelDef = getModelById(currentModelId);
    setInitialPrompt(finalDescription);

    const currentGenerationContext: GenerationContext = {
      prompt: finalDescription,
      creationMode: creationMode,
      uploadedFile: uploadedFile,
      browserInspirationUrl: scrapedUrl || browserInspirationUrl,
      figmaInspiration: figmaInspiration,
      aiProvider: aiProvider,
      modelId: currentModelId,
    };
    setGenerationContext(currentGenerationContext);
    
    setIsLoading(true);
    
    if(isPlanModeEnabled) {
      setLoadingMessage(`AI is drafting a plan...`);
      setLoadingContextPrompt(finalDescription);
      setError(null);
      addSystemMessageToTerminal(`Starting plan generation with ${aiProvider.toUpperCase()} (${modelDef?.name || currentModelId})`, 'info');
      try {
        let planResult;
        switch(aiProvider) {
          case 'openai':
            if(!openaiApiKey) throw new Error("OpenAI API Key is missing.");
            planResult = await openaiService.generateAppPlan(finalDescription, creationMode, openaiApiKey, openaiModel);
            break;
          case 'anthropic':
            if(!anthropicApiKey) throw new Error("Anthropic API Key is missing.");
            planResult = await anthropicService.generateAppPlan(finalDescription, creationMode, anthropicApiKey, anthropicModel);
            break;
          case 'gemini':
          default:
            planResult = await geminiService.generateAppPlan(finalDescription, creationMode, geminiModel);
            break;
          case 'mistral':
          case 'xai':
          case 'cohere':
          case 'meta':
            showProviderNotImplementedError(aiProvider, 'Plan generation');
            return;
        }
        setGeneratedPlan(planResult.plan);
        setCurrentView('planning');
        addSystemMessageToTerminal(`Plan generated successfully. Review and decide next steps.`, 'info');
      } catch(err) {
        console.error(`Error generating plan with ${aiProvider}:`, err);
        const errorMessage = err instanceof Error ? err.message : "An unknown error occurred. Check console.";
        setError(errorMessage);
        addSystemMessageToTerminal(`Error generating plan: ${errorMessage}`, 'error');
        setCurrentView('landing'); // Go back to landing on plan failure
      } finally {
        setIsLoading(false);
        setLoadingContextPrompt(undefined);
      }
    } else {
      addSystemMessageToTerminal(`Starting direct generation with ${aiProvider.toUpperCase()} (${modelDef?.name || currentModelId}) for: "${finalDescription.substring(0,50)}..."`, 'info');
      executeCodeGeneration(currentGenerationContext);
    }
  }, [
    apiKeyStatus, uploadedFile, browserInspirationUrl, figmaInspiration, creationMode, addSystemMessageToTerminal, saveCurrentProject,
    aiProvider, openaiApiKey, anthropicApiKey, geminiModel, openaiModel, anthropicModel, mistralModel, xaiModel, cohereModel, metaModel,
    mistralApiKey, xaiApiKey, cohereApiKey, metaApiKey, isPlanModeEnabled, executeCodeGeneration
  ]);
  
  const handleAcceptPlanAndBuild = useCallback(() => {
    if (!generationContext || !generatedPlan) return;
    addSystemMessageToTerminal("Plan accepted. Proceeding to build the application.", 'info');
    setIsLoading(true);
    executeCodeGeneration(generationContext, generatedPlan);
  }, [generationContext, generatedPlan, executeCodeGeneration]);

  const handleDeclinePlanAndBuild = useCallback(() => {
    if (!generationContext) return;
    addSystemMessageToTerminal("Plan declined. Building from original prompt.", 'info');
    setIsLoading(true);
    executeCodeGeneration(generationContext); // No plan passed
  }, [generationContext, executeCodeGeneration]);

  const handleStartNodeBuilder = () => {
    setTerminalMessages([]);
    addSystemMessageToTerminal("Launching Visual Node Builder...", 'system');
    setCurrentView('node_builder');
  };

  const handleGenerateFromNodes = async (nodes: any[], edges: any[]) => {
      const prompt = nodeBuilderService.generatePromptFromNodes(nodes, edges);
      if (!prompt) {
          setError("Could not generate a prompt from the visual plan. Ensure nodes are connected logically.");
          addSystemMessageToTerminal("Node-to-prompt conversion failed. The visual plan might be incomplete or invalid.", 'error');
          return;
      }

      addSystemMessageToTerminal("Generated detailed prompt from visual plan. Starting code generation.", 'info');
      setTerminalMessages([]);

      // Reuse existing generation logic
      const currentModelId = getCurrentActiveModelId();
      const generationContextData: GenerationContext = {
        prompt: prompt,
        creationMode: 'app', // Node builder always creates an 'app'
        uploadedFile: null,
        browserInspirationUrl: null,
        figmaInspiration: null,
        aiProvider: aiProvider,
        modelId: currentModelId,
      };
      setGenerationContext(generationContextData);
      setIsLoading(true);
      executeCodeGeneration(generationContextData);
  };


  const handleModifyCode = useCallback(async (modificationInstruction: string) => {
    const currentModelId = getCurrentActiveModelId();
    if (!checkApiKeyAndPromptModal(aiProvider, currentModelId)) { setIsLoading(false); return; }
    if (editedFiles.length === 0) { setError("No base project to modify."); return; }
    
    let finalInstruction = modificationInstruction;
    let scrapedUrl: string | undefined = undefined;
    if (modificationInstruction.toLowerCase().includes('/scrap')) {
        const parts = modificationInstruction.split('/scrap');
        const urlPart = parts[1]?.split(' ')[1];
        if (urlPart) {
            try {
                const validUrl = new URL(urlPart);
                scrapedUrl = validUrl.href;
                finalInstruction = parts[0].trim() + (parts[1].substring(urlPart.length).trim());
                addSystemMessageToTerminal(`Scraping URL: ${scrapedUrl} for modification context.`, 'info');
            } catch (e) {
                addSystemMessageToTerminal(`Invalid URL for /scrap in modification: ${urlPart}. Proceeding without scraping.`, 'warn');
            }
        } else {
             addSystemMessageToTerminal(`Malformed /scrap command. Usage: /scrap <url> <your idea>. Proceeding with full prompt.`, 'warn');
        }
    }

    const modelDef = getModelById(currentModelId);
    addSystemMessageToTerminal(`Modifying ${creationModeToLabel(creationMode)} with ${aiProvider.toUpperCase()} (${modelDef?.name || currentModelId}) using instruction: "${finalInstruction.substring(0,50)}..."`, 'info');
    setIsLoading(true);
    setLoadingMessage(`AI (${aiProvider.toUpperCase()}, ${modelDef?.name || currentModelId}) is refining your ${creationModeToLabel(creationMode).toLowerCase()}...`);
    setLoadingContextPrompt(finalInstruction);
    setError(null);
    try {
      const mediaInputPayload = (uploadedFile && !uploadedFile.mimeType.includes('zip')) ? { mimeType: uploadedFile.mimeType, base64Data: uploadedFile.base64Data } : undefined;

      let generationResult: GenerationResult;
      let modelUsed = currentModelId;

      switch(aiProvider) {
        case 'openai':
          if (!openaiApiKey) throw new Error("OpenAI API Key is missing.");
          generationResult = await openaiService.modifyAppCode(editedFiles, currentEntryPoint, finalInstruction, creationMode, openaiApiKey, openaiModel, appName, appDescription, scrapedUrl || browserInspirationUrl || undefined, figmaInspiration || undefined, mediaInputPayload);
          break;
        case 'anthropic':
          if (!anthropicApiKey) throw new Error("Anthropic API Key is missing.");
          generationResult = await anthropicService.modifyAppCode(editedFiles, currentEntryPoint, finalInstruction, creationMode, anthropicApiKey, anthropicModel, appName, appDescription, scrapedUrl || browserInspirationUrl || undefined, figmaInspiration || undefined, mediaInputPayload);
          break;
        case 'gemini':
        default: // Includes Gemini
          generationResult = await geminiService.modifyAppCode(editedFiles, currentEntryPoint, finalInstruction, creationMode, geminiModel, appName, appDescription, scrapedUrl || browserInspirationUrl || undefined, figmaInspiration || undefined, mediaInputPayload);
          break;
        case 'mistral':
        case 'xai':
        case 'cohere':
        case 'meta':
          showProviderNotImplementedError(aiProvider, `Code modification for ${creationModeToLabel(creationMode).toLowerCase()}`);
          return;
      }
      
      if (generationResult.sources && generationResult.sources.length > 0) {
        setTerminalMessages(prev => [...prev, {
            id: uuidv4(),
            level: 'system',
            payload: [`AI used web search to gather information for your request.`],
            sources: generationResult.sources,
            timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' })
        }]);
      }

      const processedResult = await processGenerationResult(generationResult.payload, finalInstruction, appName, appDescription, currentEntryPoint);

      const modifiedProjectData = {
        ...processedResult,
        mode: creationMode,
        provider: aiProvider,
        modelUsed: modelUsed
      };

      setAppName(modifiedProjectData.name);
      setAppDescription(modifiedProjectData.description);
      setEditedFiles(modifiedProjectData.files);
      setCurrentEntryPoint(modifiedProjectData.entryPoint);

      saveCurrentProject(modifiedProjectData, currentProjectId);

      setPreviewKey(prev => prev + 1);
      addSystemMessageToTerminal(`${creationModeToLabel(creationMode)} modification successful with ${aiProvider.toUpperCase()} (${modelDef?.name || modelUsed}) and project updated!`, 'info');
    } catch (err) {
      console.error(`Error modifying code with ${aiProvider} (${modelDef?.name || currentModelId}):`, err);
      const errorMessage = err instanceof Error ? err.message : "An unknown error occurred during modification. Check console.";
      setError(errorMessage);
      addSystemMessageToTerminal(`Error modifying code with ${aiProvider} (${modelDef?.name || currentModelId}): ${errorMessage}`, 'error');
    } finally { setIsLoading(false); setLoadingContextPrompt(undefined); setLoadingMessage(`Generating your app...`);}
  }, [
    editedFiles, currentEntryPoint, appName, appDescription, apiKeyStatus, uploadedFile, browserInspirationUrl, figmaInspiration, creationMode,
    addSystemMessageToTerminal, saveCurrentProject, currentProjectId,
    aiProvider, openaiApiKey, anthropicApiKey, geminiModel, openaiModel, anthropicModel, mistralModel, xaiModel, cohereModel, metaModel,
    mistralApiKey, xaiApiKey, cohereApiKey, metaApiKey
  ]);

  const handleUpdatePreviewFromEditor = useCallback(() => {
    addSystemMessageToTerminal("Manual preview update triggered.", 'info');
    setPreviewKey(prev => prev + 1);
  }, [addSystemMessageToTerminal]);

  const handleFileContentChange = useCallback((filePath: string, newContent: string) => {
    setEditedFiles(prevFiles =>
        prevFiles.map(file =>
            file.path === filePath ? { ...file, content: newContent } : file
        )
    );
  }, []);

  const handleToggleProjectSelectionForMixing = useCallback((projectId: string) => {
    setSelectedProjectIdsForMixing(prevSelectedIds =>
      prevSelectedIds.includes(projectId)
        ? prevSelectedIds.filter(id => id !== projectId)
        : [...prevSelectedIds, projectId]
    );
  }, []);

  const handleMixProjects = useCallback(async () => {
    const currentModelId = getCurrentActiveModelId();
    if (!checkApiKeyAndPromptModal(aiProvider, currentModelId)) { setIsLoading(false); return; }
    if (selectedProjectIdsForMixing.length < 2) { setError("Select at least two projects to mix."); return; }
    
    const projectsToMix = savedProjects.filter(p => selectedProjectIdsForMixing.includes(p.id));
    if (projectsToMix.length < 2) { setError("Could not find selected projects for mixing."); return; }

    const projectNames = projectsToMix.map(p => `"${p.appName}"`).join(' and ');
    const modelDef = getModelById(currentModelId);
    addSystemMessageToTerminal(`Starting project mix with ${aiProvider.toUpperCase()} (${modelDef?.name || currentModelId}) for: ${projectNames}.`, 'info');
    setIsLoading(true);
    setLoadingMessage(`Mixing ${projectNames} with ${aiProvider.toUpperCase()} (${modelDef?.name || currentModelId})...`);
    setLoadingContextPrompt(`Combine features from ${projectNames}.`);
    setTerminalMessages([]);

    try {
      let generationResult: GenerationResult;
      let modelUsed = currentModelId;
      switch(aiProvider) {
        case 'openai':
          if (!openaiApiKey) throw new Error("OpenAI API Key is missing.");
          generationResult = await openaiService.mixProjectsCode(projectsToMix, openaiApiKey, openaiModel);
          break;
        case 'anthropic':
          if (!anthropicApiKey) throw new Error("Anthropic API Key is missing.");
          generationResult = await anthropicService.mixProjectsCode(projectsToMix, anthropicApiKey, anthropicModel);
          break;
        case 'gemini':
        default: // Includes Gemini
          generationResult = await geminiService.mixProjectsCode(projectsToMix, geminiModel);
          break;
        case 'mistral':
        case 'xai':
        case 'cohere':
        case 'meta':
          showProviderNotImplementedError(aiProvider, "Project mixing");
          return;
      }
      
      if (generationResult.sources && generationResult.sources.length > 0) {
        setTerminalMessages(prev => [...prev, {
            id: uuidv4(),
            level: 'system',
            payload: [`AI used web search to gather information for your request.`],
            sources: generationResult.sources,
            timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' })
        }]);
      }

      const processedResult = await processGenerationResult(generationResult.payload, `Fusion of ${projectNames}`);

      const mixedProjectData = {
        ...processedResult,
        mode: 'app' as CreationMode,
        provider: aiProvider,
        modelUsed: modelUsed,
      };

      setAppName(mixedProjectData.name);
      setAppDescription(mixedProjectData.description);
      setEditedFiles(mixedProjectData.files);
      setCurrentEntryPoint(mixedProjectData.entryPoint);
      setCreationMode(mixedProjectData.mode);

      const newMixedProjectId = saveCurrentProject(mixedProjectData, null);
      setCurrentProjectId(newMixedProjectId);

      setPreviewKey(prev => prev + 1);
      setCurrentView('iterating');
      setSelectedProjectIdsForMixing([]);
      addSystemMessageToTerminal(`New project "${mixedProjectData.name}" (via ${aiProvider.toUpperCase()}, ${modelDef?.name || modelUsed}) created from mix and saved!`, 'info');
    } catch (err) {
       console.error(`Error mixing projects with ${aiProvider} (${modelDef?.name || currentModelId}):`, err);
      const errorMessage = err instanceof Error ? err.message : "An unknown error occurred during project mixing.";
      setError(errorMessage);
      addSystemMessageToTerminal(`Error mixing projects with ${aiProvider} (${modelDef?.name || currentModelId}): ${errorMessage}`, 'error');
    } finally { setIsLoading(false); setLoadingContextPrompt(undefined); setLoadingMessage(`Generating your app...`);}
  }, [
    selectedProjectIdsForMixing, savedProjects, addSystemMessageToTerminal, saveCurrentProject,
    aiProvider, openaiApiKey, anthropicApiKey, geminiModel, openaiModel, anthropicModel, mistralModel, xaiModel, cohereModel, metaModel,
    mistralApiKey, xaiApiKey, cohereApiKey, metaApiKey
  ]);

  const handleEnhancePrompt = useCallback(async (originalPrompt: string, mode: CreationMode): Promise<string> => {
    const currentModelId = getCurrentActiveModelId();
    if (!checkApiKeyAndPromptModal(aiProvider, currentModelId)) {
        setIsLoading(false); // Ensure global loading is also stopped
        throw new Error("API Key not configured for prompt enhancement.");
    }

    const modelDef = getModelById(currentModelId);
    addSystemMessageToTerminal(`Enhancing prompt for ${creationModeToLabel(mode)} with ${aiProvider.toUpperCase()} (${modelDef?.name || currentModelId})...`, 'info');
    setIsLoading(true);
    setLoadingMessage(`AI (${aiProvider.toUpperCase()}) is enhancing your idea...`);
    setLoadingContextPrompt(originalPrompt); // Show the original prompt while enhancing
    setError(null);

    try {
        let enhancedPrompt: string;
        switch(aiProvider) {
            case 'openai':
                if (!openaiApiKey) throw new Error("OpenAI API Key is missing for prompt enhancement.");
                enhancedPrompt = await openaiService.enhancePromptText(originalPrompt, mode, openaiApiKey, openaiModel);
                break;
            case 'anthropic':
                if (!anthropicApiKey) throw new Error("Anthropic API Key is missing for prompt enhancement.");
                enhancedPrompt = await anthropicService.enhancePromptText(originalPrompt, mode, anthropicApiKey, anthropicModel);
                break;
            case 'gemini':
            default:
                enhancedPrompt = await geminiService.enhancePromptText(originalPrompt, mode, geminiModel);
                break;
            case 'mistral':
            case 'xai':
            case 'cohere':
            case 'meta':
                showProviderNotImplementedError(aiProvider, "Prompt enhancement");
                return originalPrompt; // Return original if not implemented
        }
        addSystemMessageToTerminal(`Prompt enhanced successfully by ${aiProvider.toUpperCase()}!`, 'info');
        return enhancedPrompt;
    } catch (err) {
        console.error(`Error enhancing prompt with ${aiProvider} (${modelDef?.name || currentModelId}):`, err);
        const errorMessage = err instanceof Error ? err.message : "An unknown error occurred during prompt enhancement.";
        setError(errorMessage); // Set global error
        addSystemMessageToTerminal(`Error enhancing prompt: ${errorMessage}`, 'error');
        throw err; // Re-throw to be caught by PromptInputWithModelSelector
    } finally {
        setIsLoading(false);
        setLoadingContextPrompt(undefined);
        setLoadingMessage('Generating your app...');
    }
  }, [
    aiProvider, geminiModel, openaiModel, anthropicModel, mistralModel, xaiModel, cohereModel, metaModel, 
    openaiApiKey, anthropicApiKey, mistralApiKey, xaiApiKey, cohereApiKey, metaApiKey, addSystemMessageToTerminal, apiKeyStatus
  ]);

  const activeModelId = getCurrentActiveModelId();

  const getCurrentApiKeyForModal = () => {
    if (!showApiKeyModal) return null;
    switch(showApiKeyModal) {
        case 'openai': return openaiApiKey;
        case 'anthropic': return anthropicApiKey;
        case 'mistral': return mistralApiKey;
        case 'xai': return xaiApiKey;
        case 'cohere': return cohereApiKey;
        case 'meta': return metaApiKey;
        default: return null;
    }
  }

  const getCurrentModelForModal = () : AIProviderModel => {
    if (!showApiKeyModal) return getDefaultModelForProvider('gemini'); // Should not happen
    switch(showApiKeyModal) {
        case 'openai': return openaiModel;
        case 'anthropic': return anthropicModel;
        case 'mistral': return mistralModel;
        case 'xai': return xaiModel;
        case 'cohere': return cohereModel;
        case 'meta': return metaModel;
        default: return geminiModel;
    }
  }
  
  const handleTogglePlanMode = () => setIsPlanModeEnabled(!isPlanModeEnabled);
  
  const renderView = () => {
    switch(currentView) {
      case 'landing':
        return <LandingPage 
          theme={theme}
          onGenerate={handleInitialGenerate} 
          isLoading={isLoading} 
          initialError={error}
          uploadedFile={uploadedFile}
          onFileUpload={handleFileUpload}
          onFileRemove={handleFileRemove}
          browserInspirationUrl={browserInspirationUrl}
          onSetBrowserInspiration={handleSetBrowserInspiration}
          figmaInspiration={figmaInspiration}
          onSetFigmaInspiration={handleSetFigmaInspiration}
          creationMode={creationMode}
          onSetCreationMode={setCreationMode}
          savedProjects={savedProjects}
          onLoadProject={handleLoadProject}
          onDeleteProject={handleDeleteProject}
          selectedProjectIdsForMixing={selectedProjectIdsForMixing}
          onToggleProjectSelectionForMixing={handleToggleProjectSelectionForMixing}
          onMixProjects={handleMixProjects}
          aiProvider={aiProvider}
          currentModelId={activeModelId}
          onSelectModel={handleSelectModel}
          onEnhancePrompt={handleEnhancePrompt}
          isPlanModeEnabled={isPlanModeEnabled}
          onTogglePlanMode={handleTogglePlanMode}
          onStartVisualBuild={handleStartNodeBuilder}
        />;
      case 'planning':
        if (!generatedPlan || !generationContext) {
          setCurrentView('landing'); // Failsafe
          return null;
        }
        return <PlanningView
            theme={theme}
            plan={generatedPlan}
            originalPrompt={generationContext.prompt}
            creationMode={generationContext.creationMode}
            onAccept={handleAcceptPlanAndBuild}
            onDecline={handleDeclinePlanAndBuild}
            onCancel={() => {
                addSystemMessageToTerminal("Plan cancelled. Returning to landing page.", "system");
                setCurrentView('landing');
                setGeneratedPlan(null);
                setGenerationContext(null);
            }}
        />;
      case 'node_builder':
          return <NodeBuilderView
            onGenerate={handleGenerateFromNodes}
            onExit={() => setCurrentView('landing')}
            theme={theme}
            isLoading={isLoading}
          />;
      case 'iterating':
        return <IterationView 
          theme={theme}
          appName={appName}
          appDescription={appDescription}
          files={editedFiles}
          entryPoint={currentEntryPoint}
          onFileContentChange={handleFileContentChange}
          onModify={handleModifyCode}
          onUpdatePreview={handleUpdatePreviewFromEditor}
          onStartOver={handleStartOver}
          isLoading={isLoading}
          previewKey={previewKey}
          terminalMessages={terminalMessages}
          onClearTerminal={handleClearTerminal}
          uploadedFile={uploadedFile}
          onFileUpload={handleFileUpload}
          onFileRemove={handleFileRemove}
          browserInspirationUrl={browserInspirationUrl}
          onSetBrowserInspiration={handleSetBrowserInspiration}
          figmaInspiration={figmaInspiration}
          onSetFigmaInspiration={handleSetFigmaInspiration}
          creationMode={creationMode}
          onSetCreationMode={setCreationMode}
          aiProvider={aiProvider}
          currentModelId={activeModelId}
          onSelectModel={handleSelectModel}
          onEnhancePrompt={handleEnhancePrompt}
          isAgentModeEnabled={false} // Feature removed
          onToggleAgentMode={() => {}} // Feature removed
        />;
      default:
        return <div>Unknown view</div>;
    }
  };

  return (
    <>
      {isLoading && <LoadingSpinner isOverlay message={loadingMessage} userPrompt={loadingContextPrompt}/>}
      
      {showApiKeyModal && (
        <ApiKeyModal 
            provider={showApiKeyModal} 
            currentApiKey={getCurrentApiKeyForModal()}
            currentModelId={apiKeyModalTargetModel || getCurrentModelForModal()}
            onSave={handleSaveApiKeyConfig}
            onClose={() => {
              setShowApiKeyModal(null);
              setApiKeyModalTargetModel(undefined);
            }} 
        />
      )}
      
      {theme === 'binary' && <BinaryRain />}
      <div className="app-container">
        {renderView()}
      </div>

      <ThemeToggleButton theme={theme} onToggle={handleThemeToggle} />
    </>
  );
};

export default App;